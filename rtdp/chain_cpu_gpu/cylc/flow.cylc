[scheduler]
    allow implicit tasks = True
    UTC mode = True

[scheduling]
    cycling mode = integer
    initial cycle point = 1
    final cycle point = 1

    [[graph]]
        R1 = """
            # Start chain
            receiver:ready => chain_components:ready => sender
            
            # Completion chain
            sender:succeeded => !receiver
            receiver:completed
        """

[runtime]
    [[root]]
        # Common settings for all tasks
        platform = jlab_slurm
        [[[job]]]
            execution time limit = PT2H    # 2 hours timeout
        
        [[[directives]]]
            --ntasks = 1
            --partition = ifarm
            --output = slurm_%j.log
            --error = slurm_%j.log
        
        [[[environment]]]
            # Path to SIF files
            CPU_EMU_SIF = "$CYLC_WORKFLOW_RUN_DIR/sifs/cpu-emu.sif"
            GPU_PROXY_SIF = "$CYLC_WORKFLOW_RUN_DIR/sifs/gpu-proxy.sif"
            
            # Configuration file
            CHAIN_CONFIG = "$CYLC_WORKFLOW_RUN_DIR/chain_config.yaml"
            
            # Add local bin to PATH
            PATH = "$CYLC_WORKFLOW_RUN_DIR/bin:$PATH"
            
            # Set YQ_PATH to ensure we use the local yq
            YQ_PATH = "$CYLC_WORKFLOW_RUN_DIR/bin/yq"

            # Directory paths
            OUTPUT_DIR = "$CYLC_WORKFLOW_SHARE_DIR/output"
            INPUT_DIR = "$CYLC_WORKFLOW_SHARE_DIR/input"
            LOG_DIR = "$CYLC_WORKFLOW_SHARE_DIR/logs"

    [[chain_components]]
        [[[outputs]]]
            ready = "ready"
        [[[environment]]]
            # Add local bin to PATH for this task
            PATH = "$CYLC_WORKFLOW_RUN_DIR/bin:$PATH"
            YQ_PATH = "$CYLC_WORKFLOW_RUN_DIR/bin/yq"
        script = """
            # Create log directory
            mkdir -p ${LOG_DIR}/chain_components

            # Redirect all output to log files
            exec 1> >(tee -a "${LOG_DIR}/chain_components/stdout.log")
            exec 2> >(tee -a "${LOG_DIR}/chain_components/stderr.log")

            echo "[$(date -u '+%Y-%m-%dT%H:%M:%SZ')] Starting chain components task"
            
            # Check if yq is available
            if [ ! -x "$YQ_PATH" ]; then
                echo "ERROR: yq not found at $YQ_PATH"
                exit 1
            fi

            # Read chain configuration
            if [ ! -f "$CHAIN_CONFIG" ]; then
                echo "ERROR: Configuration file not found at $CHAIN_CONFIG"
                exit 1
            fi
            
            # Read and validate configuration
            if ! "$YQ_PATH" '.chain' "$CHAIN_CONFIG" > /dev/null; then
                echo "ERROR: Failed to parse configuration file"
                exit 1
            fi
            
            # Get the number of components
            num_components=$("$YQ_PATH" '.chain | length' "$CHAIN_CONFIG")
            if [ -z "$num_components" ]; then
                echo "ERROR: Failed to get number of components"
                exit 1
            fi
            
            if [ "$num_components" -eq 0 ]; then
                echo "ERROR: No components found in chain configuration"
                exit 1
            fi
            
            echo "Found $num_components components in configuration"
            
            # Start all components simultaneously
            echo "Starting all components simultaneously..."
            for i in $(seq 0 $((num_components-1))); do
                type=$("$YQ_PATH" ".chain[$i].type" "$CHAIN_CONFIG")
                if [ -z "$type" ]; then
                    echo "ERROR: Failed to get type for component $i"
                    exit 1
                fi
                
                node=$("$YQ_PATH" ".chain[$i].node" "$CHAIN_CONFIG")
                if [ -z "$node" ]; then
                    echo "ERROR: Failed to get node for component $i"
                    exit 1
                fi
                
                in_port=$("$YQ_PATH" ".chain[$i].in_port" "$CHAIN_CONFIG")
                if [ -z "$in_port" ]; then
                    echo "ERROR: Failed to get in_port for component $i"
                    exit 1
                fi
                
                out_port=$("$YQ_PATH" ".chain[$i].out_port" "$CHAIN_CONFIG")
                if [ -z "$out_port" ]; then
                    echo "ERROR: Failed to get out_port for component $i"
                    exit 1
                fi
                
                next_node=$("$YQ_PATH" ".chain[$((i+1))].node" "$CHAIN_CONFIG")
                if [ -z "$next_node" ] && [ $i -lt $((num_components-1)) ]; then
                    echo "ERROR: Failed to get next_node for component $i"
                    exit 1
                fi
                
                echo "Starting component $i of type $type"
                
                if [ "$type" = "cpu" ]; then
                    # CPU component
                    apptainer run --pwd /app $CPU_EMU_SIF emulator \
                        -r $in_port \
                        -i $next_node \
                        -p $out_port \
                        -t $("$YQ_PATH" ".chain[$i].params.threads" "$CHAIN_CONFIG") \
                        -b $("$YQ_PATH" ".chain[$i].params.latency" "$CHAIN_CONFIG") \
                        -m $("$YQ_PATH" ".chain[$i].params.mem_footprint" "$CHAIN_CONFIG") \
                        -o $("$YQ_PATH" ".chain[$i].params.output_size" "$CHAIN_CONFIG") \
                        2>${LOG_DIR}/chain_components/cpu_$i.log &
                else
                    # GPU component
                    apptainer run --nv --pwd /app $GPU_PROXY_SIF proxy \
                        -r $in_port \
                        -i $next_node \
                        -p $out_port \
                        -w $("$YQ_PATH" ".chain[$i].params.matrix_width" "$CHAIN_CONFIG") \
                        -s $("$YQ_PATH" ".chain[$i].params.send_rate" "$CHAIN_CONFIG") \
                        -g $("$YQ_PATH" ".chain[$i].params.group_size" "$CHAIN_CONFIG") \
                        2>${LOG_DIR}/chain_components/gpu_$i.log &
                fi
                
                # Store the PID
                COMP_PID=$!
                echo $COMP_PID > "$PID_DIR/comp_$i.pid"
            done
            
            # Wait a moment for all components to start
            echo "Waiting for all components to initialize..."
            sleep 5
            
            # Verify all components are running
            all_running=true
            for i in $(seq 0 $((num_components-1))); do
                if [ -f "$PID_DIR/comp_$i.pid" ]; then
                    pid=$(cat "$PID_DIR/comp_$i.pid")
                    if ! kill -0 $pid 2>/dev/null; then
                        echo "ERROR: Component $i failed to start"
                        cat ${LOG_DIR}/chain_components/*_$i.log >&2
                        all_running=false
                    else
                        echo "Component $i is running with PID $pid"
                    fi
                else
                    echo "ERROR: PID file not found for component $i"
                    all_running=false
                fi
            done
            
            if [ "$all_running" = false ]; then
                echo "ERROR: Not all components started successfully"
                exit 1
            fi
            
            # Signal that all components are ready
            echo "[$(date -u '+%Y-%m-%dT%H:%M:%SZ')] Signaling ready state"
            cylc message "ready"
            echo "[$(date -u '+%Y-%m-%dT%H:%M:%SZ')] Ready message sent"
            
            # Wait for all components to complete
            for i in $(seq 0 $((num_components-1))); do
                if [ -f "$PID_DIR/comp_$i.pid" ]; then
                    wait $(cat "$PID_DIR/comp_$i.pid")
                fi
            done
        """
        [[[directives]]]
            --job-name = chain_components
            --cpus-per-task = 8
            --mem = 16G
            --partition = gpu
            --gres = gpu:A100:1

    [[sender]]
        [[[outputs]]]
            ready = "ready"
        [[[environment]]]
            # Add local bin to PATH for this task
            PATH = "$CYLC_WORKFLOW_RUN_DIR/bin:$PATH"
        script = """
            # Create log directory
            mkdir -p ${LOG_DIR}/sender

            # Redirect all output to log files
            exec 1> >(tee -a "${LOG_DIR}/sender/stdout.log")
            exec 2> >(tee -a "${LOG_DIR}/sender/stderr.log")

            echo "[$(date -u '+%Y-%m-%dT%H:%M:%SZ')] Starting sender task"
            
            # Read chain configuration
            config=$(cat $CHAIN_CONFIG)
            first_comp=$(echo "$config" | yq '.chain[0]')
            first_node=$(echo "$first_comp" | yq '.node')
            first_port=$(echo "$first_comp" | yq '.in_port')
            
            # Create input directory
            mkdir -p ${INPUT_DIR}
            
            # Run sender
            apptainer run --pwd /app $CPU_EMU_SIF sender -i $first_node -p $first_port 2>${LOG_DIR}/sender/apptainer.log
            
            # Signal completion
            cylc message -- "send_complete"
        """

    [[receiver]]
        script = """
            # Create log directory
            mkdir -p ${LOG_DIR}/receiver

            # Redirect all output to log files
            exec 1> >(tee -a "${LOG_DIR}/receiver/stdout.log")
            exec 2> >(tee -a "${LOG_DIR}/receiver/stderr.log")

            echo "[$(date -u '+%Y-%m-%dT%H:%M:%SZ')] Starting receiver task"
            
            # Check if yq is available
            if [ ! -x "$YQ_PATH" ]; then
                echo "ERROR: yq not found at $YQ_PATH"
                exit 1
            fi

            # Read chain configuration
            if [ ! -f "$CHAIN_CONFIG" ]; then
                echo "ERROR: Configuration file not found at $CHAIN_CONFIG"
                exit 1
            fi
            
            # Create a temporary file for yq output
            TMP_FILE=$(mktemp)
            if [ $? -ne 0 ]; then
                echo "ERROR: Failed to create temporary file"
                exit 1
            fi
            trap 'rm -f "$TMP_FILE"' EXIT
            
            # Read and validate configuration
            if ! "$YQ_PATH" '.chain' "$CHAIN_CONFIG" > "$TMP_FILE"; then
                echo "ERROR: Failed to parse configuration file"
                exit 1
            fi
            
            if [ ! -s "$TMP_FILE" ]; then
                echo "ERROR: Configuration file is empty or invalid"
                exit 1
            fi
            
            # Get the number of components
            num_components=$("$YQ_PATH" '. | length' "$TMP_FILE")
            if [ "$num_components" -eq 0 ]; then
                echo "ERROR: No components found in chain configuration"
                exit 1
            fi
            
            # Get the last component
            last_comp=$("$YQ_PATH" ".[$((num_components-1))]" "$TMP_FILE")
            if [ -z "$last_comp" ]; then
                echo "ERROR: Failed to get last component from configuration"
                exit 1
            fi
            
            # Extract the output port
            last_port=$("$YQ_PATH" '.out_port' <<< "$last_comp")
            if [ -z "$last_port" ]; then
                echo "ERROR: Failed to get output port from last component"
                exit 1
            fi
            
            echo "Starting receiver on port $last_port"
            
            # Create output directory
            mkdir -p ${OUTPUT_DIR}
            
            # Start receiver in background
            apptainer run --pwd /app $CPU_EMU_SIF receiver -z -r $last_port > ${OUTPUT_DIR}/received_data.bin 2>${LOG_DIR}/receiver/apptainer.log &
            
            RECV_PID=$!
            echo "[$(date -u '+%Y-%m-%dT%H:%M:%SZ')] Receiver started with PID ${RECV_PID}"
            
            # Brief pause to let process start
            sleep 2
            
            # Signal readiness if process is running
            if kill -0 $RECV_PID 2>/dev/null; then
                echo "[$(date -u '+%Y-%m-%dT%H:%M:%SZ')] Signaling ready state"
                cylc message "ready"
                echo "[$(date -u '+%Y-%m-%dT%H:%M:%SZ')] Ready message sent"
            else
                echo "[$(date -u '+%Y-%m-%dT%H:%M:%SZ')] ERROR: Receiver process not running" >&2
                cat ${LOG_DIR}/receiver/apptainer.log >&2
                exit 1
            fi
            
            # Create a flag file to indicate we should keep running
            KEEP_RUNNING=1
            trap 'KEEP_RUNNING=0' TERM INT
            
            # Create a flag file to track completion
            COMPLETION_FILE="${CYLC_WORKFLOW_SHARE_DIR}/receiver_complete"
            rm -f "${COMPLETION_FILE}"
            
            # Initialize file size tracking
            PREV_SIZE=0
            if [ -f "${OUTPUT_DIR}/received_data.bin" ]; then
                PREV_SIZE=$(stat -c %s "${OUTPUT_DIR}/received_data.bin" || echo 0)
            fi
            
            # Monitor the receiver process
            while [ $KEEP_RUNNING -eq 1 ] && kill -0 $RECV_PID 2>/dev/null; do
                echo "[$(date -u '+%Y-%m-%dT%H:%M:%SZ')] Receiver process is running (PID: $RECV_PID)"
                echo "Process details:" >> ${LOG_DIR}/receiver/process.log
                ps -fp $RECV_PID >> ${LOG_DIR}/receiver/process.log 2>&1 || true
                
                # Check if data has been received by monitoring file size changes
                CURRENT_SIZE=0
                if [ -f "${OUTPUT_DIR}/received_data.bin" ]; then
                    CURRENT_SIZE=$(stat -c %s "${OUTPUT_DIR}/received_data.bin" || echo 0)
                fi
                
                if [ $CURRENT_SIZE -gt $PREV_SIZE ] && [ ! -f "${COMPLETION_FILE}" ]; then
                    echo "[$(date -u '+%Y-%m-%dT%H:%M:%SZ')] Data received successfully (size: $CURRENT_SIZE bytes)"
                    echo "Transfer completed successfully"
                    cylc message -- "Transfer completed successfully"
                    touch "${COMPLETION_FILE}"
                fi
                
                PREV_SIZE=$CURRENT_SIZE
                sleep 5
            done
            
            # Check final status
            FINAL_SIZE=0
            if [ -f "${OUTPUT_DIR}/received_data.bin" ]; then
                FINAL_SIZE=$(stat -c %s "${OUTPUT_DIR}/received_data.bin" || echo 0)
            fi
            
            if [ $FINAL_SIZE -gt 0 ]; then
                echo "[$(date -u '+%Y-%m-%dT%H:%M:%SZ')] Transfer completed successfully (final size: $FINAL_SIZE bytes)"
                exit 0
            else
                echo "[$(date -u '+%Y-%m-%dT%H:%M:%SZ')] ERROR: Transfer failed or incomplete" >&2
                echo "Last few lines of apptainer log:" >&2
                tail -n 20 ${LOG_DIR}/receiver/apptainer.log >&2
                exit 1
            fi
        """
        [[[outputs]]]
            ready = "ready"
            completed = "Transfer completed successfully"
        [[[environment]]]
            # Add local bin to PATH for this task
            PATH = "$CYLC_WORKFLOW_RUN_DIR/bin:$PATH"
            YQ_PATH = "$CYLC_WORKFLOW_RUN_DIR/bin/yq"
            TMP_FILE = "$(mktemp)" 