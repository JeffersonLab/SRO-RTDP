[scheduler]
    allow implicit tasks = True
    UTC mode = True

[scheduling]
    cycling mode = integer
    initial cycle point = 1
    final cycle point = 1

    [[graph]]
        R1 = """
            # Start chain
            receiver:ready => chain_components:ready => sender
            
            # Completion chain (separate from start chain)
            sender:send_complete => !receiver
            receiver:completed
        """

[runtime]
    [[root]]
        # Common settings for all tasks
        platform = jlab_slurm
        [[[job]]]
            execution time limit = PT2H    # 2 hours timeout
        
        [[[directives]]]
            --ntasks = 1
            --partition = ifarm
            --output = slurm_%j.log
            --error = slurm_%j.log
        
        [[[environment]]]
            # Path to SIF files
            CPU_EMU_SIF = "$CYLC_WORKFLOW_RUN_DIR/sifs/cpu-emu.sif"
            GPU_PROXY_SIF = "$CYLC_WORKFLOW_RUN_DIR/sifs/gpu-proxy.sif"
            
            # Configuration file
            CHAIN_CONFIG = "$CYLC_WORKFLOW_RUN_DIR/chain_config.yaml"
            
            # Add local bin to PATH
            PATH = "$CYLC_WORKFLOW_RUN_DIR/bin:$PATH"
            
            # Set YQ_PATH to ensure we use the local yq
            YQ_PATH = "$CYLC_WORKFLOW_RUN_DIR/bin/yq"

            # Directory paths
            OUTPUT_DIR = "$CYLC_WORKFLOW_SHARE_DIR/output"
            INPUT_DIR = "$CYLC_WORKFLOW_SHARE_DIR/input"
            LOG_DIR = "$CYLC_WORKFLOW_SHARE_DIR/logs"

    [[chain_components]]
        [[[outputs]]]
            ready = "ready"
        [[[environment]]]
            # Add local bin to PATH for this task
            PATH = "$CYLC_WORKFLOW_RUN_DIR/bin:$PATH"
            YQ_PATH = "$CYLC_WORKFLOW_RUN_DIR/bin/yq"
        script = """
            # Create log directory
            mkdir -p ${LOG_DIR}/chain_components

            # Redirect all output to log files
            exec 1> >(tee -a "${LOG_DIR}/chain_components/stdout.log")
            exec 2> >(tee -a "${LOG_DIR}/chain_components/stderr.log")

            echo "[$(date -u '+%Y-%m-%dT%H:%M:%SZ')] Starting chain components task"
            
            # Check if yq is available
            if [ ! -x "$YQ_PATH" ]; then
                echo "ERROR: yq not found at $YQ_PATH"
                exit 1
            fi

            # Read chain configuration
            if [ ! -f "$CHAIN_CONFIG" ]; then
                echo "ERROR: Configuration file not found at $CHAIN_CONFIG"
                exit 1
            fi
            
            # Create a temporary file for yq output
            TMP_FILE=$(mktemp)
            trap 'rm -f "$TMP_FILE"' EXIT
            
            # Read and validate configuration
            if ! "$YQ_PATH" '.chain' "$CHAIN_CONFIG" > "$TMP_FILE"; then
                echo "ERROR: Failed to parse configuration file"
                exit 1
            fi
            
            if [ ! -s "$TMP_FILE" ]; then
                echo "ERROR: Configuration file is empty or invalid"
                exit 1
            fi
            
            # Get the number of components
            num_components=$("$YQ_PATH" '. | length' "$TMP_FILE")
            if [ "$num_components" -eq 0 ]; then
                echo "ERROR: No components found in chain configuration"
                exit 1
            fi
            
            # Start each component sequentially
            for i in $(seq 0 $((num_components-1))); do
                comp=$("$YQ_PATH" ".chain[$i]" "$CHAIN_CONFIG")
                type=$("$YQ_PATH" '.type' <<< "$comp")
                node=$("$YQ_PATH" '.node' <<< "$comp")
                in_port=$("$YQ_PATH" '.in_port' <<< "$comp")
                out_port=$("$YQ_PATH" '.out_port' <<< "$comp")
                next_node=$("$YQ_PATH" ".chain[$((i+1))].node" "$CHAIN_CONFIG")
                
                echo "Starting component $i of type $type"
                
                if [ "$type" = "cpu" ]; then
                    # CPU component
                    apptainer run --pwd /app $CPU_EMU_SIF emulator \
                        -r $in_port \
                        -i $next_node \
                        -p $out_port \
                        -t $("$YQ_PATH" '.params.threads' <<< "$comp") \
                        -b $("$YQ_PATH" '.params.latency' <<< "$comp") \
                        -m $("$YQ_PATH" '.params.mem_footprint' <<< "$comp") \
                        -o $("$YQ_PATH" '.params.output_size' <<< "$comp") \
                        2>${LOG_DIR}/chain_components/cpu_$i.log &
                else
                    # GPU component
                    apptainer run --nv --pwd /app $GPU_PROXY_SIF proxy \
                        -r $in_port \
                        -i $next_node \
                        -p $out_port \
                        -w $("$YQ_PATH" '.params.matrix_width' <<< "$comp") \
                        -s $("$YQ_PATH" '.params.send_rate' <<< "$comp") \
                        -g $("$YQ_PATH" '.params.group_size' <<< "$comp") \
                        2>${LOG_DIR}/chain_components/gpu_$i.log &
                fi
                
                # Store the PID
                COMP_PID=$!
                echo $COMP_PID > "$PID_DIR/comp_$i.pid"
                
                # Wait for the component to be ready
                echo "Waiting for component $i to be ready..."
                sleep 2  # Give it time to start
                
                # Check if the process is still running
                if ! kill -0 $COMP_PID 2>/dev/null; then
                    echo "ERROR: Component $i failed to start"
                    cat ${LOG_DIR}/chain_components/${type}_$i.log >&2
                    exit 1
                fi
                
                echo "Component $i is ready"
            done
            
            # Signal that all components are ready
            cylc message "ready"
            
            # Wait for all components to complete
            for i in $(seq 0 $((num_components-1))); do
                if [ -f "$PID_DIR/comp_$i.pid" ]; then
                    wait $(cat "$PID_DIR/comp_$i.pid")
                fi
            done
        """
        [[[directives]]]
            --job-name = chain_components
            --cpus-per-task = 8
            --mem = 16G
            --partition = gpu
            --gres = gpu:A100:1

    [[sender]]
        [[[outputs]]]
            ready = "ready"
            send_complete = "send_complete"
        [[[environment]]]
            # Add local bin to PATH for this task
            PATH = "$CYLC_WORKFLOW_RUN_DIR/bin:$PATH"
        script = """
            # Create log directory
            mkdir -p ${LOG_DIR}/sender

            # Redirect all output to log files
            exec 1> >(tee -a "${LOG_DIR}/sender/stdout.log")
            exec 2> >(tee -a "${LOG_DIR}/sender/stderr.log")

            echo "[$(date -u '+%Y-%m-%dT%H:%M:%SZ')] Starting sender task"
            
            # Read chain configuration
            config=$(cat $CHAIN_CONFIG)
            first_comp=$(echo "$config" | yq '.chain[0]')
            first_node=$(echo "$first_comp" | yq '.node')
            first_port=$(echo "$first_comp" | yq '.in_port')
            
            # Create input directory
            mkdir -p ${INPUT_DIR}
            
            # Run sender
            apptainer run --pwd /app $CPU_EMU_SIF sender -i $first_node -p $first_port 2>${LOG_DIR}/sender/apptainer.log
            
            # Signal completion
            cylc message -- "send_complete"
        """

    [[receiver]]
        script = """
            # Create log directory
            mkdir -p ${LOG_DIR}/receiver

            # Redirect all output to log files
            exec 1> >(tee -a "${LOG_DIR}/receiver/stdout.log")
            exec 2> >(tee -a "${LOG_DIR}/receiver/stderr.log")

            echo "[$(date -u '+%Y-%m-%dT%H:%M:%SZ')] Starting receiver task"
            
            # Check if yq is available
            if [ ! -x "$YQ_PATH" ]; then
                echo "ERROR: yq not found at $YQ_PATH"
                exit 1
            fi

            # Read chain configuration
            if [ ! -f "$CHAIN_CONFIG" ]; then
                echo "ERROR: Configuration file not found at $CHAIN_CONFIG"
                exit 1
            fi
            
            # Create a temporary file for yq output
            TMP_FILE=$(mktemp)
            if [ $? -ne 0 ]; then
                echo "ERROR: Failed to create temporary file"
                exit 1
            fi
            trap 'rm -f "$TMP_FILE"' EXIT
            
            # Read and validate configuration
            if ! "$YQ_PATH" '.chain' "$CHAIN_CONFIG" > "$TMP_FILE"; then
                echo "ERROR: Failed to parse configuration file"
                exit 1
            fi
            
            if [ ! -s "$TMP_FILE" ]; then
                echo "ERROR: Configuration file is empty or invalid"
                exit 1
            fi
            
            # Get the number of components
            num_components=$("$YQ_PATH" '. | length' "$TMP_FILE")
            if [ "$num_components" -eq 0 ]; then
                echo "ERROR: No components found in chain configuration"
                exit 1
            fi
            
            # Get the last component
            last_comp=$("$YQ_PATH" ".[$((num_components-1))]" "$TMP_FILE")
            if [ -z "$last_comp" ]; then
                echo "ERROR: Failed to get last component from configuration"
                exit 1
            fi
            
            # Extract the output port
            last_port=$("$YQ_PATH" '.out_port' <<< "$last_comp")
            if [ -z "$last_port" ]; then
                echo "ERROR: Failed to get output port from last component"
                exit 1
            fi
            
            echo "Starting receiver on port $last_port"
            
            # Create output directory
            mkdir -p ${OUTPUT_DIR}
            
            # Run receiver with correct command format for entrypoint
            apptainer run --pwd /app $CPU_EMU_SIF receiver -z -r $last_port > ${OUTPUT_DIR}/received_data.bin 2>${LOG_DIR}/receiver/apptainer.log
            
            # Signal completion
            cylc message -- "Transfer completed successfully"
        """
        [[[outputs]]]
            ready = "ready"
            completed = "Transfer completed successfully"
        [[[environment]]]
            # Add local bin to PATH for this task
            PATH = "$CYLC_WORKFLOW_RUN_DIR/bin:$PATH"
            YQ_PATH = "$CYLC_WORKFLOW_RUN_DIR/bin/yq"
            TMP_FILE = "$(mktemp)" 