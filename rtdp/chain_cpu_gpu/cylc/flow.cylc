[scheduler]
    allow implicit tasks = True
    UTC mode = True

[scheduling]
    cycling mode = integer
    initial cycle point = 1
    final cycle point = 1

    [[graph]]
        R1 = """
            # Start chain
            receiver:ready => chain_components:ready => sender
            
            # Completion chain (separate from start chain)
            sender:send_complete => !receiver
            receiver:completed
        """

[runtime]
    [[root]]
        # Common settings for all tasks
        platform = jlab_slurm
        [[[job]]]
            execution time limit = PT2H    # 2 hours timeout
        
        [[[directives]]]
            --ntasks = 1
            --partition = ifarm
            --output = slurm_%j.log
            --error = slurm_%j.log
        
        [[[environment]]]
            # Path to SIF files
            CPU_EMU_SIF = "$CYLC_WORKFLOW_RUN_DIR/sifs/cpu-emu.sif"
            GPU_PROXY_SIF = "$CYLC_WORKFLOW_RUN_DIR/sifs/gpu-proxy.sif"
            
            # Configuration file
            CHAIN_CONFIG = "$CYLC_WORKFLOW_RUN_DIR/chain_config.yaml"
            
            # Add local bin to PATH
            PATH = "$CYLC_WORKFLOW_RUN_DIR/bin:$PATH"
            
            # Set YQ_PATH to ensure we use the local yq
            YQ_PATH = "$CYLC_WORKFLOW_RUN_DIR/bin/yq"

    [[chain_components]]
        [[[outputs]]]
            ready = "ready"
        [[[environment]]]
            # Add local bin to PATH for this task
            PATH = "$CYLC_WORKFLOW_RUN_DIR/bin:$PATH"
            YQ_PATH = "$CYLC_WORKFLOW_RUN_DIR/bin/yq"
        script = """
            # Read chain configuration
            config=$(cat $CHAIN_CONFIG)
            num_components=$(echo "$config" | yq '.chain | length')
            
            # Create a temporary directory for component PIDs
            PID_DIR=$(mktemp -d)
            trap 'rm -rf "$PID_DIR"' EXIT
            
            # Start each component sequentially
            for i in $(seq 0 $((num_components-1))); do
                comp=$(echo "$config" | yq ".chain[$i]")
                type=$(echo "$comp" | yq '.type')
                node=$(echo "$comp" | yq '.node')
                in_port=$(echo "$comp" | yq '.in_port')
                out_port=$(echo "$comp" | yq '.out_port')
                next_node=$(echo "$config" | yq ".chain[$((i+1))].node")
                
                echo "Starting component $i of type $type"
                
                if [ "$type" = "cpu" ]; then
                    # CPU component
                    apptainer exec $CPU_EMU_SIF ./cpu_emu \
                        -r $in_port \
                        -i $next_node \
                        -p $out_port \
                        -t $(echo "$comp" | yq '.params.threads') \
                        -b $(echo "$comp" | yq '.params.latency') \
                        -m $(echo "$comp" | yq '.params.mem_footprint') \
                        -o $(echo "$comp" | yq '.params.output_size') &
                else
                    # GPU component
                    apptainer exec --nv $GPU_PROXY_SIF ./gpuEmu \
                        -r $in_port \
                        -i $next_node \
                        -p $out_port \
                        -w $(echo "$comp" | yq '.params.matrix_width') \
                        -s $(echo "$comp" | yq '.params.send_rate') \
                        -g $(echo "$comp" | yq '.params.group_size') &
                fi
                
                # Store the PID
                COMP_PID=$!
                echo $COMP_PID > "$PID_DIR/comp_$i.pid"
                
                # Wait for the component to be ready
                echo "Waiting for component $i to be ready..."
                sleep 2  # Give it time to start
                
                # Check if the process is still running
                if ! kill -0 $COMP_PID 2>/dev/null; then
                    echo "ERROR: Component $i failed to start"
                    exit 1
                fi
                
                echo "Component $i is ready"
            done
            
            # Signal that all components are ready
            cylc message "ready"
            
            # Wait for all components to complete
            for i in $(seq 0 $((num_components-1))); do
                if [ -f "$PID_DIR/comp_$i.pid" ]; then
                    wait $(cat "$PID_DIR/comp_$i.pid")
                fi
            done
        """
        [[[directives]]]
            --job-name = chain_components
            --cpus-per-task = 8
            --mem = 16G
            --partition = gpu
            --gres = gpu:A100:1

    [[sender]]
        [[[outputs]]]
            ready = "ready"
            send_complete = "send_complete"
        [[[environment]]]
            # Add local bin to PATH for this task
            PATH = "$CYLC_WORKFLOW_RUN_DIR/bin:$PATH"
        script = """
            # Read chain configuration
            config=$(cat $CHAIN_CONFIG)
            first_comp=$(echo "$config" | yq '.chain[0]')
            first_node=$(echo "$first_comp" | yq '.node')
            first_port=$(echo "$first_comp" | yq '.in_port')
            
            # Run sender
            apptainer exec $CPU_EMU_SIF ./zmq-event-clnt -i $first_node -p $first_port
            
            # Signal completion
            cylc message -- "send_complete"
        """

    [[receiver]]
        [[[outputs]]]
            ready = "ready"
            completed = "Transfer completed successfully"
        [[[environment]]]
            # Add local bin to PATH for this task
            PATH = "$CYLC_WORKFLOW_RUN_DIR/bin:$PATH"
            YQ_PATH = "$CYLC_WORKFLOW_RUN_DIR/bin/yq"
        script = """
            # Check if yq is available
            if [ ! -x "$YQ_PATH" ]; then
                echo "ERROR: yq not found at $YQ_PATH"
                exit 1
            fi

            # Read chain configuration
            if [ ! -f "$CHAIN_CONFIG" ]; then
                echo "ERROR: Configuration file not found at $CHAIN_CONFIG"
                exit 1
            fi
            
            # Create a temporary file for yq output
            TMP_FILE=$(mktemp)
            trap 'rm -f "$TMP_FILE"' EXIT
            
            # Read and validate configuration
            if ! "$YQ_PATH" '.chain' "$CHAIN_CONFIG" > "$TMP_FILE"; then
                echo "ERROR: Failed to parse configuration file"
                exit 1
            fi
            
            if [ ! -s "$TMP_FILE" ]; then
                echo "ERROR: Configuration file is empty or invalid"
                exit 1
            fi
            
            # Get the number of components
            num_components=$("$YQ_PATH" '. | length' "$TMP_FILE")
            if [ "$num_components" -eq 0 ]; then
                echo "ERROR: No components found in chain configuration"
                exit 1
            fi
            
            # Get the last component
            last_comp=$("$YQ_PATH" ".[$((num_components-1))]" "$TMP_FILE")
            if [ -z "$last_comp" ]; then
                echo "ERROR: Failed to get last component from configuration"
                exit 1
            fi
            
            # Extract the output port
            last_port=$(echo "$last_comp" | "$YQ_PATH" '.out_port')
            if [ -z "$last_port" ]; then
                echo "ERROR: Failed to get output port from last component"
                exit 1
            fi
            
            echo "Starting receiver on port $last_port"
            
            # Run receiver
            apptainer exec $CPU_EMU_SIF ./cpu_emu -r $last_port -z 1
            
            # Signal completion
            cylc message -- "Transfer completed successfully"
        """ 