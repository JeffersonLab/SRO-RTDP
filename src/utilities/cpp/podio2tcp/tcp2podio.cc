//---------------------------------------------------------------------------
// This is an example program that can establish a tcp connection to a
// podio2tcp instance and receive events from it. It deomstrates how
// to unpack the packets of events and access the podio trees they
// contain. Each packet contains the full metadata trees and an
// events tree with one or more events in it.
//
// Multiple instances of this can attach to the same podio2tcp instance
// and they will each receive a fraction of the published events
// via round-robin load balancing.
//
// It's the server end.
//---------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include <string>
#include <chrono>
#include <unistd.h> // For getpid()

#include <TFile.h>
#include <TMemFile.h>
#include <TTree.h>
#include <TMessage.h>
#include <TBufferFile.h>
#include <TKey.h>
#include <TError.h>

#include <zmq.hpp>

int DEFAULT_ZMQ_PORT = 55577;  // must keep aligned with value in podio2tcp.cc !!

#include "SQLiteRateLogger.h"

// Global SQlite Rate logger
/// NOTE: data schema for the receiver DB
sqlite> .schema rate_logs
CREATE TABLE rate_logs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    timestamp_utc_ms INTEGER,
    pid STRING,
    rateHz_recv_period REAL,
    rateMbps_recv_period REAL
);
SQLiteRateLogger rate_logger;
std::string RATE_DB_COLUMNS = "timestamp_utc_ms, pid, "
                            "rateHz_recv_period, "
                            "rateMbps_recv_period";


// special class needed to expose protected TMessage constructor
class MyTMessage : public TMessage {
public:
   MyTMessage(void *buf, Int_t len) : TMessage(buf, len) { }
};

//.........................................................................
// The following was mostly generated by ChatGPT from a detailed prompt.
class CommandLineOptions {
public:
    std::string inputFilename;
    std::string outfile;
    int port = DEFAULT_ZMQ_PORT; // Default
    int groupevents = 50;
    bool loop = false;
    double rate = 0.0; // Unset
    std::string sqliteFilename;      // SQL file parameter
    std::string ipAddress = "localhost";

    static CommandLineOptions Parse(int argc, char* argv[]) {
        CommandLineOptions options;
        for (int i = 1; i < argc; ++i) {
            std::string arg = argv[i];
            if (arg == "-h" || arg == "--help") {
                PrintUsage();
                exit(0);
            } else if (arg == "-p" || arg == "--port") {
                if (i + 1 < argc) {
                    options.port = std::stoi(argv[++i]);
                }
            } else if (arg == "-i" || arg == "--ip-address") {
                if (i + 1 < argc) {
                    options.ipAddress = argv[++i];
                }
            } else if (arg == "-s" || arg == "--sqlfile") {
                if (i + 1 < argc) {
                    options.sqliteFilename = argv[++i];
                }
            }
        }

        return options;
    }

    static void PrintUsage() {
        std::cout << "\n" 
                  << "Usage: tcp2podio [-p port]\n"
                  << "\n"
                  << "-h, --help   Print this help statement\n"
                  << "-i, --ip-address <ip> Set the local IP address ZMQ to listen (default is 'localhost')\n"
                  << "-p, --port <port> Set ZMQ port to listen on (default is 55577)\n"
                  << "-s, --sqlfile <file> Specify the SQL rate logger file\n"
                  << "\n"
                  << "This is used to listen for events coming from an instance of podio2tcp\n."
                  << "It is only for testing the rate at which data is transferred and unmarshalled\n"
                  << "into TTrees. The data is discarded after that."
                  << "\n"
                  << "If --sqlfile is used, it specifies the SQLite database output.\n"
                  << "\n";
    }
};
//.........................................................................


int main(int narg, char *argv[]){

    // Parse command options (will print help and exit if help is asked for)
    CommandLineOptions options = CommandLineOptions::Parse(narg, argv);

    // This suppresses those annoying warnings about no dictionary when
    // the ROOT file is opened. (It probably suppresses others too.)
    gErrorIgnoreLevel = kError;

    // Setup network communication via zmq
    zmq::context_t context(1);
    zmq::socket_t worker(context, ZMQ_PULL);
    worker.set(zmq::sockopt::rcvhwm, 10); // Set High Water Mark for maximum number of messages to queue before stalling
    std::string bindAddress = "tcp://" + options.ipAddress + ":" + std::to_string(options.port);
    try {
        worker.bind(bindAddress.c_str());
        std::cout << "ZeroMQ SERVER binded to: " << bindAddress << "\n";
    } catch (const zmq::error_t& e) {
        std::cout << "Error: Failed to bind to the address [" << bindAddress << "]:" << e.what() << "\n";
        return 1;
    }
    std::cout << "\nWaiting for data ..." << std::endl;

    // Setup SQLite3 database connection
    if (!options.sqliteFilename.empty() && !rate_logger.openDB(options.sqliteFilename)) {
        std::cerr << "Failed to open database: " << options.sqliteFilename << std::endl;
        return 1;
    }

    auto last_time = std::chrono::high_resolution_clock::now();
    while (true) {
            zmq::message_t task;
            auto res = worker.recv(task, zmq::recv_flags::none);

            // std::cout << "Received buffer: " << task.size() << std::endl;
            if( task.size() == 0 ){ std::cout << "(skipping empty buffer)" << std::endl; continue;}

            // Create TMemFile from buffer
            MyTMessage *myTM = new MyTMessage((char*)task.data(), task.size());
            Long64_t length=0;
            myTM->ReadLong64(length);
            TDirectory *savedir = gDirectory;
            TMemFile *f = new TMemFile("tmpdir", myTM->Buffer() + myTM->Length(), length);
            savedir->cd();

            // Get pointers to TTrees
            TTree* events_tree = nullptr;
            TTree* runs_tree = nullptr;
            TTree* metadata_tree = nullptr;
            TTree* podio_metadata_tree = nullptr;
            if( f->IsOpen()){
                f->GetObject("events", events_tree);
                f->GetObject("runs", runs_tree);
                f->GetObject("metadata", metadata_tree);
                f->GetObject("podio_metadata", podio_metadata_tree);
            }

            // Print ticker
            auto Nbytes_received = task.size();
            Long64_t Nevents_in_buffer = 0;
            if( events_tree ) Nevents_in_buffer = events_tree->GetEntries();

            auto now = std::chrono::high_resolution_clock::now();
            auto duration = std::chrono::duration<double>(now - last_time).count();
            auto rateMbps = Nbytes_received/duration*8.0/1.0E6;
            auto rateHz = Nevents_in_buffer/duration;
            auto savePrecision = std::cout.precision();
            std::cout << "  " << std::fixed << std::setprecision(3) << rateHz << " Hz  (" << rateMbps << " Mbps)" << std::endl;
            std::cout.precision(savePrecision);

            // Log to SQLite DB
            auto utc_timestamp_in_ms =
                std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()).count();
            std::string pid_str = std::to_string(getpid());
            std::ostringstream values;
            values << std::to_string(utc_timestamp_in_ms) << ", "
                << pid_str << ", "
                << std::fixed << std::setprecision(3)  // Ensure consistent floating-point precision
                << rateHz << ", "
                << rateMbps;
            if (!rate_logger.insertRateLog(RATE_DB_COLUMNS, values.str())) {
                std::cerr << "Failed to insert record into the database." << std::endl;
            }

            last_time = now;

            delete f;

            // std::this_thread::sleep_for(std::chrono::seconds(1));
    }
    // Close SQLite3 DB
    rate_logger.closeDB();

    return 0;
}